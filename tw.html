<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Novel Crawler</title>
  <style>
    body{font-family:'Segoe UI',Tahoma,Geneva,Verdana,sans-serif;max-width:800px;margin:0 auto;padding:20px;background:#f5f5f5}
    h1{color:#333;text-align:center}
    .container{background:#fff;padding:20px;border-radius:8px;box-shadow:0 2px 10px rgba(0,0,0,.1)}
    .form-group{margin-bottom:15px}
    label{display:block;margin-bottom:5px;font-weight:bold}
    input[type=text]{width:100%;padding:8px;border:1px solid #ddd;border-radius:4px;box-sizing:border-box}
    button{background:#4CAF50;color:#fff;border:none;padding:10px 15px;border-radius:4px;cursor:pointer;font-size:16px;margin-right:10px}
    button:disabled{background:#ccc}
    #console, #console-translate{padding:15px;border-radius:4px;font-family:'Courier New',Courier,monospace;height:300px;overflow-y:auto;white-space:pre-wrap;margin-top:20px}
    #console{background:#1e1e1e;color:#d4d4d4;}
    #console-translate{background:#f0f0ff;color:#000;}
    .progress-container{margin-top:15px;display:none}
    progress{width:100%}
    .status{text-align:center;margin:10px 0;font-weight:bold}
  </style>
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
</head>
<body>
  <div class="container">
    <h1>Novel Crawler</h1>

    <div class="form-group">
      <label for="novelUrl">Novel URL:</label>
      <input type="text" id="novelUrl" placeholder="link">
    </div>

    <button id="fetchMetadataBtn">Fetch Metadata</button>
    <button id="fetchChaptersBtn" disabled>Fetch Chapters</button>
    <button id="downloadBtn" disabled>Download as JSON</button>
    <button id="saveToJsonBtn" disabled>Save JSON</button> 
    <button id="editMetadataBtn" disabled>Edit Metadata</button>
    <button id="saveMetadataBtn">Save Metadata</button>

    <div class="progress-container" id="progressContainer">
      <div class="status" id="statusText">Processing...</div>
      <progress id="progressBar" value="0" max="100"></progress>
    </div>

    <div id="console"></div>
    <div id="console-translate"></div>
    <button id="saveTranslationBtn" disabled>Save Translation</button>
  </div>

  <script>
    // ---- DOM refs ----
    const consoleOutput   = document.getElementById('console');
    const consoleTranslate= document.getElementById('console-translate');
    const saveTranslationBtn = document.getElementById('saveTranslationBtn');
    const novelUrlInput   = document.getElementById('novelUrl');
    const fetchMetadataBtn= document.getElementById('fetchMetadataBtn');
    const fetchChaptersBtn= document.getElementById('fetchChaptersBtn');
    const downloadBtn     = document.getElementById('downloadBtn');
    const saveToJsonBtn   = document.getElementById('saveToJsonBtn'); 
    const progressContainer = document.getElementById('progressContainer');
    const progressBar     = document.getElementById('progressBar');
    const statusText      = document.getElementById('statusText');

    // ---- config ----
    const WORKER_URL = 'https://curly-pond-9050.yuush.workers.dev';

    // ---- helpers ----
    function log(msg, color = '') {
      const messageElement = document.createElement('div');
      messageElement.textContent = msg;
      if (color) {
        messageElement.style.color = color;
        messageElement.style.fontWeight = 'bold';
      }
      consoleOutput.appendChild(messageElement);
      consoleOutput.scrollTop = consoleOutput.scrollHeight;
    }

    function updateProgress(current, total) {
      const pct = Math.round((current / total) * 100);
      progressBar.value = pct;
      statusText.textContent = `Processing ${current}/${total} (${pct}%)`;
    }

    // ---- data store ----
    let novelData = { metadata: null, chapters: [] };

    // ---- fetch raw html via worker ----
    async function fetchRawHTML(targetUrl) {
      const res = await fetch(`${WORKER_URL}/api/raw?url=${encodeURIComponent(targetUrl)}`);
      if (!res.ok) throw new Error(`raw fetch ${res.status}`);
      return res.text();
    }

    // ---- fetch metadata (browser-side) ----
    async function fetchMetadata() {
      const url = novelUrlInput.value.trim();
      if (!url) return alert('Please enter a novel URL');

      try {
        log('Fetching novel page…');
        fetchMetadataBtn.disabled = true;

        const html = await fetchRawHTML(url);
        const doc = new DOMParser().parseFromString(html, 'text/html');

        const title = doc.querySelector('.n-text h1')?.textContent.trim() || 'Untitled';
        const cover = doc.querySelector('.n-img img')?.src || '';
        const author = doc.querySelector('.n-text p a.bauthor')?.textContent.trim() || 'Unknown';
        const status = doc.querySelector('.n-text p .lz')?.textContent.trim() 
            || doc.querySelector('.n-text p .end')?.textContent.trim() 
            || 'Unknown';
        const description = doc.querySelector('#intro')?.textContent.trim() || '';
        const Url = doc.querySelector('.n-text a.bauthor')?.getAttribute('href') || null;
        const authorUrl = Url ? new URL(Url, url).href : null;
        const genres = Array.from(doc.querySelectorAll('.tags em a')).map(a => a.textContent.trim());

        const lastLink = doc.querySelector('.u-chapter.cfirst li a:last-of-type');
        if (!lastLink) throw new Error("Couldn't find last chapter link");
        const href = lastLink.getAttribute('href');
        const match = href.match(/p(\d+)\.html$/);
        if (!match) throw new Error("Couldn't extract last chapter number");
        const lastNumber = parseInt(match[1], 10);

        const chapters = [];
        for (let i = 1; i <= lastNumber; i++) {
          chapters.push({
            title: `Chapter ${i}`,
            url: new URL(`p${i}.html`, url).href
          });
        }

        novelData.metadata = { title, cover, author, status, genres, description, authorUrl };
        novelData.chapters = chapters;

        log(`\n=== Metadata ===`);
        log(`Title: ${title}`);
        log(`Cover: ${cover}`);
        log(`Author: ${author}`);
        log(`Status: ${status}`);
        log(`Genres: ${genres.join(', ')}`);
        log(`Description: ${description}`);
        log(`Total chapters found: ${chapters.length}`);
        fetchChaptersBtn.disabled = false;

      } catch (err) {
        log(`Error: ${err.message}`, 'red');
        fetchMetadataBtn.disabled = false;
      }
    }

    // ---- fetch chapter content ----
    async function fetchChapterContent(chapterUrl) {
      const html = await fetchRawHTML(chapterUrl);
      const doc  = new DOMParser().parseFromString(html, 'text/html');
      const title = doc.querySelector('.page-content h3')?.textContent?.trim() || 'Untitled Chapter';
      const paragraphs = [...doc.querySelectorAll('.page-content p')]
        .filter(p => !p.classList.contains('abg') && !p.closest('.ad') && !p.closest('.ads'))
        .map(p => p.textContent.trim())
        .filter(txt => txt.length > 0);
      const content = paragraphs.map(txt => `<p>${txt}</p>`).join('\n');
      return { title, content };
    }

    // ---- TRANSLATION MODE ----
    let currentBatchIndex = 0;
    let batchSize = 100;

    function showTranslateJson(batch) {
      consoleTranslate.textContent = JSON.stringify(batch, null, 2);
      saveTranslationBtn.disabled = false;
    }

    async function fetchChapters() {
      if (!novelData.chapters.length) return alert('No chapters found');
      try {
        fetchChaptersBtn.disabled = true;
        progressContainer.style.display = 'block';
        currentBatchIndex = 0;
        await fetchNextBatch();
      } catch (err) {
        log(`Error: ${err.message}`, 'red');
        fetchChaptersBtn.disabled = false;
        progressContainer.style.display = 'none';
      }
    }

    async function fetchNextBatch() {
      const total = novelData.chapters.length;
      const start = currentBatchIndex * batchSize;
      const end = Math.min(start + batchSize, total);

      if (start >= total) {
        log('\n✅ All chapters processed!', 'green');
        downloadBtn.disabled = false;
        saveToJsonBtn.disabled = false;
        progressContainer.style.display = 'none';
        saveTranslationBtn.disabled = true;
        return;
      }

      log(`\nFetching batch ${currentBatchIndex + 1}: chapters ${start + 1}-${end}`);
      const slice = novelData.chapters.slice(start, end);
      const promises = slice.map(async (ch, idx) => {
        log(`Fetching ${start + idx + 1}/${total} - ${ch.title}`);
        const data = await fetchChapterContent(ch.url);
        return { ...ch, ...data };
      });

      const results = await Promise.all(promises);
      results.forEach((r, idx) => (novelData.chapters[start + idx] = r));
      updateProgress(end, total);

      // Show for manual translation
      showTranslateJson(results);
    }

    saveTranslationBtn.addEventListener('click', () => {
      try {
        const translatedText = consoleTranslate.textContent.trim();
        if (!translatedText) return alert('No translated text found');
        const translatedJson = JSON.parse(translatedText);
        const start = currentBatchIndex * batchSize;
        for (let i = 0; i < translatedJson.length; i++) {
          novelData.chapters[start + i] = {
            ...novelData.chapters[start + i],
            ...translatedJson[i]
          };
        }
        log(`✅ Saved translation for batch ${currentBatchIndex + 1}`, 'green');
        saveTranslationBtn.disabled = true;
        currentBatchIndex++;
        fetchNextBatch();
      } catch (err) {
        log(`Error parsing translation JSON: ${err.message}`, 'red');
      }
    });

    // ---- export JSON ----
    function downloadJson() {
      if (!novelData.metadata?.title) return alert('No data to save');
      const cleanData = {
        ...novelData,
        chapters: novelData.chapters.map(({ url, ...rest }) => rest)
      };
      const blob = new Blob([JSON.stringify(cleanData, null, 2)], { type: 'application/json' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = `${novelData.metadata.title.replace(/[^a-z0-9]/gi, '_')}.json`;
      a.click();
      URL.revokeObjectURL(a.href);
    }

    // ---- events ----
    fetchMetadataBtn.addEventListener('click', fetchMetadata);
    fetchChaptersBtn.addEventListener('click', fetchChapters);
    downloadBtn.addEventListener('click', downloadJson);
  </script>
</body>
</html>
