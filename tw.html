<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Novel Crawler</title>
  <style>
    body{font-family:'Segoe UI',Tahoma,sans-serif;max-width:900px;margin:0 auto;padding:20px;background:#f5f5f5}
    h1{text-align:center}
    .container{background:#fff;padding:20px;border-radius:8px;box-shadow:0 2px 8px rgba(0,0,0,.1)}
    .form-group{margin-bottom:12px}
    label{display:block;margin-bottom:4px;font-weight:bold}
    input[type=text],textarea{width:100%;padding:6px;border:1px solid #ccc;border-radius:4px;box-sizing:border-box}
    button{background:#4CAF50;color:#fff;border:none;padding:8px 12px;margin:4px 2px;border-radius:4px;cursor:pointer}
    button:disabled{background:#aaa}
    #console,#console-translate{padding:12px;border-radius:4px;font-family:monospace;height:250px;overflow-y:auto;white-space:pre-wrap;margin-top:12px}
    #console{background:#1e1e1e;color:#d4d4d4}
    #console-translate{background:#f0f0ff;color:#000}
    .progress-container{margin-top:12px;display:none}
    progress{width:100%}
    .status{text-align:center;margin:6px 0;font-weight:bold}
    .json-item{margin-bottom:6px}
    .json-key,.json-syntax{color:#444;font-weight:bold}
    .tval{background:rgba(255,255,0,.1);padding:0 2px}
    .muted{opacity:.7;font-size:.9em}
  </style>
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
</head>
<body>
<div class="container">
  <h1>Novel Crawler</h1>

  <div class="form-group">
    <label for="novelUrl">Novel URL:</label>
    <input type="text" id="novelUrl" placeholder="https://...">
  </div>

  <div>
    <button id="fetchMetadataBtn">Fetch Metadata</button>
    <button id="editMetadataBtn" disabled>Edit Metadata</button>
    <button id="saveMetadataBtn" disabled>Save Metadata</button>
    <button id="fetchChaptersBtn" disabled>Fetch Chapters</button>
    <button id="saveTranslationBtn" disabled>Save Translation</button>
    <button id="createEpubBtn" disabled>Create EPUB</button>
    <button id="downloadEpubBtn" disabled>Download EPUB</button>
    <button id="downloadJsonBtn" disabled>Download JSON</button>
  </div>

  <div class="progress-container" id="progressContainer">
    <div class="status" id="statusText">Processing…</div>
    <progress id="progressBar" value="0" max="100"></progress>
  </div>

  <div id="console"></div>
  <div id="console-translate" class="notranslate"></div>
  <div class="muted">Tip: Use Chrome’s Translate for the highlighted values. Keys and punctuation are protected.</div>
</div>

<script>
const consoleOutput=document.getElementById('console');
const consoleTranslate=document.getElementById('console-translate');
const novelUrlInput=document.getElementById('novelUrl');

const fetchMetadataBtn=document.getElementById('fetchMetadataBtn');
const editMetadataBtn=document.getElementById('editMetadataBtn');
const saveMetadataBtn=document.getElementById('saveMetadataBtn');
const fetchChaptersBtn=document.getElementById('fetchChaptersBtn');
const saveTranslationBtn=document.getElementById('saveTranslationBtn');
const createEpubBtn=document.getElementById('createEpubBtn');
const downloadEpubBtn=document.getElementById('downloadEpubBtn');
const downloadJsonBtn=document.getElementById('downloadJsonBtn');

const progressContainer=document.getElementById('progressContainer');
const progressBar=document.getElementById('progressBar');
const statusText=document.getElementById('statusText');

const WORKER_URL="https://curly-pond-9050.yuush.workers.dev";

function log(msg,color=""){const el=document.createElement('div');el.textContent=msg;if(color){el.style.color=color;el.style.fontWeight="bold"}consoleOutput.appendChild(el);consoleOutput.scrollTop=consoleOutput.scrollHeight;}
function updateProgress(cur,total){const pct=Math.round((cur/total)*100);progressBar.value=pct;statusText.textContent=`Processing ${cur}/${total} (${pct}%)`;}

// Data
let novelData={metadata:null,chapters:[]};

// Worker fetch
async function fetchRawHTML(u){const r=await fetch(`${WORKER_URL}/api/raw?url=${encodeURIComponent(u)}`);if(!r.ok)throw new Error(r.status);return r.text();}

// Metadata
async function fetchMetadata(){
  const url=novelUrlInput.value.trim();if(!url)return alert("Enter URL");
  try{
    log("Fetching novel page…");
    fetchMetadataBtn.disabled=true;
    const html=await fetchRawHTML(url);
    const doc=new DOMParser().parseFromString(html,"text/html");
    const title=doc.querySelector(".n-text h1")?.textContent.trim()||"Untitled";
    const cover=doc.querySelector(".n-img img")?.src||"";
    const author=doc.querySelector(".n-text p a.bauthor")?.textContent.trim()||"Unknown";
    const status=doc.querySelector(".n-text p .lz")?.textContent.trim()||doc.querySelector(".n-text p .end")?.textContent.trim()||"Unknown";
    const description=doc.querySelector("#intro")?.textContent.trim()||"";
    const Url=doc.querySelector(".n-text a.bauthor")?.getAttribute("href")||null;
    const authorUrl=Url?new URL(Url,url).href:null;
    const genres=Array.from(doc.querySelectorAll(".tags em a")).map(a=>a.textContent.trim());
    const lastLink=doc.querySelector(".u-chapter.cfirst li a:last-of-type");
    if(!lastLink)throw new Error("No last chapter link");
    const match=lastLink.getAttribute("href").match(/p(\d+)\.html$/);if(!match)throw new Error("Bad chapter url");
    const lastNumber=parseInt(match[1],10);
    const chapters=[];for(let i=1;i<=lastNumber;i++){chapters.push({title:`Chapter ${i}`,url:new URL(`p${i}.html`,url).href});}
    novelData.metadata={title,cover,author,status,genres,description,authorUrl};
    novelData.chapters=chapters;
    log("=== Metadata ===");log(`Title: ${title}`);log(`Author: ${author}`);log(`Status: ${status}`);log(`Chapters: ${chapters.length}`);
    editMetadataBtn.disabled=false;fetchChaptersBtn.disabled=false;
  }catch(e){log("Error "+e.message,"red");fetchMetadataBtn.disabled=false;}
}

// Metadata editor inline
function editMetadata(){
  if(!novelData.metadata)return;
  consoleOutput.innerHTML=`
    <div><label>Title<input id="mTitle" type="text" value="${novelData.metadata.title}"></label></div>
    <div><label>Author<input id="mAuthor" type="text" value="${novelData.metadata.author}"></label></div>
    <div><label>Status<input id="mStatus" type="text" value="${novelData.metadata.status}"></label></div>
    <div><label>Genres<input id="mGenres" type="text" value="${novelData.metadata.genres.join(", ")}"></label></div>
    <div><label>Cover URL<input id="mCover" type="text" value="${novelData.metadata.cover}"></label></div>
    <div><label>Author URL<input id="mAuthorUrl" type="text" value="${novelData.metadata.authorUrl||""}"></label></div>
    <div><label>Description<textarea id="mDesc">${novelData.metadata.description}</textarea></label></div>
  `;
  saveMetadataBtn.disabled=false;
}

function saveMetadata(){
  novelData.metadata.title=document.getElementById("mTitle").value.trim();
  novelData.metadata.author=document.getElementById("mAuthor").value.trim();
  novelData.metadata.status=document.getElementById("mStatus").value.trim();
  novelData.metadata.genres=document.getElementById("mGenres").value.split(",").map(g=>g.trim()).filter(Boolean);
  novelData.metadata.cover=document.getElementById("mCover").value.trim();
  novelData.metadata.authorUrl=document.getElementById("mAuthorUrl").value.trim();
  novelData.metadata.description=document.getElementById("mDesc").value.trim();
  log("✅ Metadata updated","green");
  saveMetadataBtn.disabled=true;
}

// Chapter fetch
async function fetchChapterContent(u){
  const html=await fetchRawHTML(u);
  const doc=new DOMParser().parseFromString(html,"text/html");
  const title=doc.querySelector(".page-content h3")?.textContent.trim()||"Untitled";
  const paras=[...doc.querySelectorAll(".page-content p")].filter(p=>!p.classList.contains("abg")&&!p.closest(".ad")&&!p.closest(".ads")).map(p=>p.textContent.trim()).filter(t=>t.length>0);
  return{title,content:paras.map(t=>`<p>${t}</p>`).join("\n")};
}

// Translation flow
let currentBatchIndex=0;const batchSize=50;let currentBatchStart=0;let currentBatchData=[];
function escapeHTML(s){return String(s).replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;");}

function showTranslateJson(batch,start){
  currentBatchStart=start;currentBatchData=batch;
  consoleTranslate.innerHTML="";
  const wrap=document.createElement("div");wrap.setAttribute("translate","no");
  wrap.innerHTML+="[";
  batch.forEach((it,i)=>{
    wrap.innerHTML+=`
      <div class="json-item">
      { "index": ${start+i}, "title": "<span class='tval' translate='yes' data-i='${i}' data-k='title'>${escapeHTML(it.title)}</span>", 
      "content": "<span class='tval' translate='yes' data-i='${i}' data-k='content'>${it.content}</span>" }${i<batch.length-1?",":""}
      </div>`;
  });
  wrap.innerHTML+="]";
  consoleTranslate.appendChild(wrap);
  saveTranslationBtn.disabled=false;
}

function readTranslatedBatch(){
  return currentBatchData.map((it,i)=>({
    ...it,
    title:(consoleTranslate.querySelector(`.tval[data-i='${i}'][data-k='title']`)?.textContent||"").trim(),
    content:(consoleTranslate.querySelector(`.tval[data-i='${i}'][data-k='content']`)?.innerHTML||"")
  }));
}

async function fetchChapters(){
  if(!novelData.chapters.length)return;
  fetchChaptersBtn.disabled=true;
  progressContainer.style.display="block";
  currentBatchIndex=0;
  await fetchNextBatch();
}

async function fetchNextBatch(){
  const total=novelData.chapters.length;
  const start=currentBatchIndex*batchSize;
  const end=Math.min(start+batchSize,total);
  if(start>=total){log("✅ All chapters fetched","green");progressContainer.style.display="none";createEpubBtn.disabled=false;downloadJsonBtn.disabled=false;return;}
  const slice=novelData.chapters.slice(start,end);
  log(`Fetching batch ${currentBatchIndex+1}: ${start+1}-${end}`);
  const res=await Promise.all(slice.map((ch,idx)=>fetchChapterContent(ch.url)));
  res.forEach((r,i)=>novelData.chapters[start+i]={...slice[i],...r});
  updateProgress(end,total);
  showTranslateJson(res,start);
}

saveTranslationBtn.addEventListener("click",()=>{
  const trans=readTranslatedBatch();
  trans.forEach((t,i)=>{novelData.chapters[currentBatchStart+i]={...novelData.chapters[currentBatchStart+i],title:t.title,content:t.content}});
  log(`Saved batch ${currentBatchIndex+1}`,"green");
  saveTranslationBtn.disabled=true;
  currentBatchIndex++;fetchNextBatch();
});

// Export JSON
function downloadJson(){
  const clean={...novelData,chapters:novelData.chapters.map(({url,...rest})=>rest)};
  const blob=new Blob([JSON.stringify(clean,null,2)],{type:"application/json"});
  const a=document.createElement("a");a.href=URL.createObjectURL(blob);
  a.download=`${novelData.metadata.title.replace(/[^a-z0-9]/gi,"_")}.json`;a.click();
  URL.revokeObjectURL(a.href);
}

// EPUB
let lastEpubBlob=null;
function createEpub(){
  const zip=new JSZip();
  zip.file("mimetype","application/epub+zip");
  const meta=novelData.metadata;
  // container
  zip.file("META-INF/container.xml",`<?xml version="1.0"?>
    <container version="1.0" xmlns="urn:oasis:names:tc:opendocument:xmlns:container">
    <rootfiles><rootfile full-path="OEBPS/content.opf" media-type="application/oebps-package+xml"/></rootfiles></container>`);
  // chapters
  novelData.chapters.forEach((ch,i)=>{
    zip.file(`OEBPS/ch${i+1}.xhtml`,`<?xml version="1.0" encoding="utf-8"?>
    <html xmlns="http://www.w3.org/1999/xhtml"><head><title>${ch.title}</title></head><body><h2>${ch.title}</h2>${ch.content}</body></html>`);
  });
  // toc & opf minimal
  const manifest=novelData.chapters.map((ch,i)=>`<item id="c${i+1}" href="ch${i+1}.xhtml" media-type="application/xhtml+xml"/>`).join("\n");
  const spine=novelData.chapters.map((ch,i)=>`<itemref idref="c${i+1}"/>`).join("\n");
  const opf=`<?xml version="1.0" encoding="utf-8"?>
  <package version="2.0" xmlns="http://www.idpf.org/2007/opf" unique-identifier="BookId">
  <metadata xmlns:dc="http://purl.org/dc/elements/1.1/"><dc:title>${meta.title}</dc:title><dc:creator>${meta.author}</dc:creator><dc:language>en</dc:language></metadata>
  <manifest>${manifest}</manifest><spine toc="ncx">${spine}</spine></package>`;
  zip.file("OEBPS/content.opf",opf);
  zip.generateAsync({type:"blob"}).then(b=>{lastEpubBlob=b;log("✅ EPUB created","green");downloadEpubBtn.disabled=false;});
}

function downloadEpub(){
  if(!lastEpubBlob)return;
  const a=document.createElement("a");a.href=URL.createObjectURL(lastEpubBlob);
  a.download=`${novelData.metadata.title.replace(/[^a-z0-9]/gi,"_")}.epub`;a.click();URL.revokeObjectURL(a.href);
}

// Events
fetchMetadataBtn.onclick=fetchMetadata;
editMetadataBtn.onclick=editMetadata;
saveMetadataBtn.onclick=saveMetadata;
fetchChaptersBtn.onclick=fetchChapters;
downloadJsonBtn.onclick=downloadJson;
createEpubBtn.onclick=createEpub;
downloadEpubBtn.onclick=downloadEpub;
</script>
</body>
</html>
