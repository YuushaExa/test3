<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WTR-LAB Novel JSON Fetcher</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        
        .container {
            background: white;
            border-radius: 16px;
            padding: 30px;
            max-width: 800px;
            width: 100%;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }
        
        h1 {
            color: #333;
            margin-bottom: 20px;
            text-align: center;
            font-size: 28px;
        }
        
        .input-group {
            margin-bottom: 20px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            color: #555;
            font-weight: 600;
            font-size: 14px;
        }
        
        input[type="url"] {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
        }
        
        input[type="url"]:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        
        button {
            flex: 1;
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            color: white;
        }
        
        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        .fetch-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        
        .fetch-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        .show-btn {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }
        
        .show-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(245, 87, 108, 0.4);
        }
        
        .status {
            margin-top: 20px;
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            line-height: 1.6;
        }
        
        .status.info {
            background: #e3f2fd;
            color: #1976d2;
            border-left: 4px solid #2196f3;
        }
        
        .status.success {
            background: #e8f5e9;
            color: #2e7d32;
            border-left: 4px solid #4caf50;
        }
        
        .status.error {
            background: #ffebee;
            color: #c62828;
            border-left: 4px solid #f44336;
        }
        
        .status.warning {
            background: #fff8e1;
            color: #5d4037;
            border-left: 4px solid #ff9800;
        }
        
        .progress {
            margin-top: 15px;
        }
        
        .progress-bar {
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 5px;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            transition: width 0.3s;
            width: 0%;
        }
        
        .progress-text {
            font-size: 12px;
            color: #666;
            text-align: center;
        }
        
        .example {
            margin-top: 15px;
            font-size: 13px;
            color: #888;
        }
        
        .example code {
            background: #f5f5f5;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: monospace;
        }
        
        .loader {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s linear infinite;
            margin-right: 8px;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .button-text {
            display: flex;
            align-items: center;
            justify-content: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üìñ WTR-LAB Novel JSON Fetcher</h1>
        
        <div class="input-group">
            <label for="novelUrl">Enter Novel URL:</label>
            <input 
                type="url" 
                id="novelUrl" 
                placeholder="https://wtr-lab.com/en/novel/12958/wizard-start-by-synthesizing-gems"
                value="https://wtr-lab.com/en/novel/12958/wizard-start-by-synthesizing-gems"
            >
            <div class="example">
                Example: <code>https://wtr-lab.com/en/novel/12958/wizard-start-by-synthesizing-gems</code>
            </div>
        </div>
        
        <div class="button-group">
            <button id="fetchBtn" class="fetch-btn">
                <span class="button-text">üöÄ Fetch Novel Data</span>
            </button>
            <button id="showBtn" class="show-btn" disabled>
                <span class="button-text">üìÑ Show JSON</span>
            </button>
        </div>
        
        <div id="status" class="status info" style="display: none;">
            Ready to fetch. Click "Fetch Novel Data" to begin.
        </div>
        
        <div id="progress" class="progress" style="display: none;">
            <div class="progress-bar">
                <div id="progressFill" class="progress-fill"></div>
            </div>
            <div id="progressText" class="progress-text">0%</div>
        </div>
    </div>

    <script>
        // Global variable to store fetched data
        let novelData = null;
        let isFetching = false;
        
        const fetchBtn = document.getElementById('fetchBtn');
        const showBtn = document.getElementById('showBtn');
        const statusEl = document.getElementById('status');
        const progressEl = document.getElementById('progress');
        const progressFill = document.getElementById('progressFill');
        const progressText = document.getElementById('progressText');
        const novelUrlInput = document.getElementById('novelUrl');
        
        // Show status message
        function showStatus(message, type = 'info') {
            statusEl.textContent = message;
            statusEl.className = `status ${type}`;
            statusEl.style.display = 'block';
        }
        
        // Show progress
        function showProgress() {
            progressEl.style.display = 'block';
        }
        
        // Update progress bar
        function updateProgress(current, total) {
            const percent = Math.round((current / total) * 100);
            progressFill.style.width = `${percent}%`;
            progressText.textContent = `${percent}% (${current}/${total})`;
        }
        
        // Hide progress
        function hideProgress() {
            progressEl.style.display = 'none';
        }
        
        // Set button loading state
        function setButtonLoading(button, isLoading, originalText) {
            const buttonText = button.querySelector('.button-text');
            if (isLoading) {
                buttonText.innerHTML = '<span class="loader"></span>Processing...';
                button.disabled = true;
            } else {
                buttonText.textContent = originalText;
                button.disabled = false;
            }
        }
        
        // Extract novel ID and language from URL
        function extractNovelInfo(url) {
            const urlObj = new URL(url);
            const pathname = urlObj.pathname;
            const parts = pathname.split('/').filter(p => p);
            
            // Expected format: /en/novel/12958/wizard-start-by-synthesizing-gems
            const novelIndex = parts.indexOf('novel');
            if (novelIndex === -1 || novelIndex + 1 >= parts.length) {
                throw new Error('Invalid URL format. Expected: /novel/{id}/...');
            }
            
            return {
                id: parts[novelIndex + 1],
                language: parts[novelIndex - 1] || 'en'
            };
        }
        
        // Fetch chapter list
        async function fetchChapterList(novelId) {
            const response = await fetch(`https://wtr-lab.com/api/chapters/${novelId}`, {
                credentials: 'include'
            });
            
            if (!response.ok) {
                throw new Error(`Failed to fetch chapters: ${response.status}`);
            }
            
            const data = await response.json();
            return data.chapters || [];
        }
        
        // Fetch chapter content
        async function fetchChapterContent(novelId, language, chapterOrder) {
            const formData = {
                translate: "ai",
                language: language,
                raw_id: novelId,
                chapter_no: chapterOrder
            };
            
            const response = await fetch("https://wtr-lab.com/api/reader/get", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json;charset=UTF-8"
                },
                body: JSON.stringify(formData),
                credentials: "include"
            });
            
            if (!response.ok) {
                throw new Error(`Failed to fetch chapter ${chapterOrder}: ${response.status}`);
            }
            
            const data = await response.json();
            
            if (!data?.data?.data?.body) {
                throw new Error(`No content found for chapter ${chapterOrder}`);
            }
            
            // Process chapter body
            let content = '';
            let imgCounter = 0;
            
            data.data.data.body.forEach(el => {
                if (el === "[image]") {
                    const src = data.data.data?.images?.[imgCounter++] ?? "";
                    if (src) {
                        content += `[IMAGE: ${src}]\n`;
                    }
                } else {
                    // Extract text from HTML
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = el;
                    let text = tempDiv.textContent || '';
                    
                    // Apply glossary replacements
                    for (let i = 0; i < (data?.data?.data?.glossary_data?.terms?.length ?? 0); i++) {
                        const term = data.data.data.glossary_data.terms[i][0] ?? `‚Äª${i}‚õ¨`;
                        text = text.replaceAll(`‚Äª${i}‚õ¨`, term);
                    }
                    
                    content += text + '\n';
                }
            });
            
            return {
                title: data.chapter?.title || `Chapter ${chapterOrder}`,
                content: content.trim(),
                order: chapterOrder
            };
        }
        
        // Fetch cover image URL
        async function fetchCoverImageUrl(novelId) {
            try {
                // Try to get cover from the novel page
                const novelPageUrl = `https://wtr-lab.com/en/novel/${novelId}`;
                const response = await fetch(novelPageUrl);
                const html = await response.text();
                
                // Parse HTML to find cover
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                
                // Try multiple selectors
                let coverUrl = null;
                
                // Method 1: Next.js JSON data
                const nextDataScript = doc.querySelector('script#__NEXT_DATA__');
                if (nextDataScript) {
                    try {
                        const jsonData = JSON.parse(nextDataScript.textContent);
                        coverUrl = jsonData?.props?.pageProps?.series?.cover ||
                                   jsonData?.props?.pageProps?.novel?.cover ||
                                   jsonData?.props?.initialState?.series?.cover;
                    } catch (e) {
                        console.warn('Failed to parse Next.js data:', e);
                    }
                }
                
                // Method 2: picture/source tags
                if (!coverUrl) {
                    const pictureSource = doc.querySelector('picture source[srcset]');
                    if (pictureSource) {
                        coverUrl = pictureSource.srcset;
                    }
                }
                
                // Method 3: img tags with CDN URLs
                if (!coverUrl) {
                    const imgs = doc.querySelectorAll('img');
                    for (const img of imgs) {
                        if (img.src && img.src.includes('/cdn/series/') && !img.src.includes('/placeholder')) {
                            coverUrl = img.src;
                            break;
                        }
                    }
                }
                
                return coverUrl;
            } catch (error) {
                console.warn('Failed to fetch cover image:', error);
                return null;
            }
        }
        
        // Main fetch function
        async function fetchNovelData() {
            if (isFetching) return;
            
            isFetching = true;
            const url = novelUrlInput.value.trim();
            
            if (!url) {
                showStatus('Please enter a novel URL', 'error');
                isFetching = false;
                return;
            }
            
            try {
                // Validate and extract info
                showStatus('üîç Extracting novel information...', 'info');
                setButtonLoading(fetchBtn, true, 'Fetch Novel Data');
                
                const { id: novelId, language } = extractNovelInfo(url);
                showStatus(`Novel ID: ${novelId}, Language: ${language}`, 'info');
                
                // Fetch chapter list
                showStatus('üìö Fetching chapter list...', 'info');
                const chapters = await fetchChapterList(novelId);
                
                if (!chapters || chapters.length === 0) {
                    throw new Error('No chapters found for this novel');
                }
                
                showStatus(`Found ${chapters.length} chapters. Starting download...`, 'success');
                showProgress();
                
                // Fetch cover image
                showStatus('üñºÔ∏è Fetching cover image...', 'info');
                const coverUrl = await fetchCoverImageUrl(novelId);
                
                // Fetch all chapters with delay
                const allChapters = [];
                const totalChapters = chapters.length;
                
                for (let i = 0; i < totalChapters; i++) {
                    const chapter = chapters[i];
                    const chapterOrder = chapter.order;
                    
                    showStatus(`üìñ Fetching chapter ${chapterOrder} of ${totalChapters}...`, 'info');
                    updateProgress(i + 1, totalChapters);
                    
                    try {
                        const chapterData = await fetchChapterContent(novelId, language, chapterOrder);
                        allChapters.push(chapterData);
                        
                        // Add 12-second delay between chapters (except last one)
                        if (i < totalChapters - 1) {
                            showStatus(`‚è≥ Waiting 12 seconds before next chapter...`, 'warning');
                            await new Promise(resolve => setTimeout(resolve, 12000));
                        }
                    } catch (error) {
                        console.error(`Failed to fetch chapter ${chapterOrder}:`, error);
                        showStatus(`‚ö†Ô∏è Chapter ${chapterOrder} failed, skipping...`, 'warning');
                        // Continue with next chapter
                        allChapters.push({
                            order: chapterOrder,
                            title: chapter.title || `Chapter ${chapterOrder}`,
                            content: '[ERROR: Failed to fetch this chapter]',
                            error: true
                        });
                    }
                }
                
                // Build final JSON structure
                novelData = {
                    metadata: {
                        novelId: novelId,
                        language: language,
                        title: chapters[0]?.novel_title || 'Unknown Title',
                        coverUrl: coverUrl,
                        totalChapters: totalChapters,
                        fetchedAt: new Date().toISOString(),
                        source: url
                    },
                    chapters: allChapters.sort((a, b) => a.order - b.order)
                };
                
                hideProgress();
                showStatus(`‚úÖ Successfully fetched ${allChapters.length} chapters!`, 'success');
                showBtn.disabled = false;
                
            } catch (error) {
                hideProgress();
                showStatus(`‚ùå Error: ${error.message}`, 'error');
                console.error('Fetch error:', error);
            } finally {
                setButtonLoading(fetchBtn, false, 'Fetch Novel Data');
                isFetching = false;
            }
        }
        
        // Show JSON in new page
        function showJSON() {
            if (!novelData) {
                showStatus('No data to show. Please fetch first.', 'error');
                return;
            }
            
            // Create JSON string with indentation
            const jsonString = JSON.stringify(novelData, null, 2);
            
            // Open in new window
            const newWindow = window.open('', '_blank');
            newWindow.document.write(`
                <!DOCTYPE html>
                <html lang="en">
                <head>
                    <meta charset="UTF-8">
                    <meta name="viewport" content="width=device-width, initial-scale=1.0">
                    <title>Novel JSON Data</title>
                    <style>
                        body {
                            font-family: 'Courier New', monospace;
                            background: #1e1e1e;
                            color: #d4d4d4;
                            padding: 20px;
                            margin: 0;
                        }
                        pre {
                            white-space: pre-wrap;
                            word-wrap: break-word;
                            max-width: 100%;
                        }
                        .header {
                            background: #2d2d2d;
                            padding: 15px;
                            border-bottom: 2px solid #569cd6;
                            margin-bottom: 20px;
                        }
                        .header h1 {
                            color: #569cd6;
                            margin: 0;
                        }
                        .download-btn {
                            background: #0e639c;
                            color: white;
                            padding: 10px 20px;
                            border: none;
                            border-radius: 5px;
                            cursor: pointer;
                            font-size: 14px;
                            margin-top: 10px;
                        }
                        .download-btn:hover {
                            background: #1177bb;
                        }
                    </style>
                </head>
                <body>
                    <div class="header">
                        <h1>üìñ Novel JSON Data</h1>
                        <button class="download-btn" onclick="downloadJSON()">üíæ Download JSON</button>
                    </div>
                    <pre id="jsonContent">${jsonString}</pre>
                    
                    <script>
                        function downloadJSON() {
                            const data = ${JSON.stringify(jsonString)};
                            const blob = new Blob([data], { type: 'application/json' });
                            const url = URL.createObjectURL(blob);
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = 'novel_data.json';
                            document.body.appendChild(a);
                            a.click();
                            document.body.removeChild(a);
                            URL.revokeObjectURL(url);
                        }
                    </script>
                </body>
                </html>
            `);
            newWindow.document.close();
        }
        
        // Event listeners
        fetchBtn.addEventListener('click', fetchNovelData);
        showBtn.addEventListener('click', showJSON);
        
        // Auto-focus on input
        novelUrlInput.focus();
        
        // Show initial status
        showStatus('Enter a WTR-LAB novel URL and click "Fetch Novel Data" to begin.', 'info');
    </script>
</body>
</html>
