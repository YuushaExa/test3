<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Novel Crawler</title>
  <style>
    body{font-family:'Segoe UI',Tahoma,Geneva,Verdana,sans-serif;max-width:800px;margin:0 auto;padding:20px;background:#f5f5f5}
    h1{color:#333;text-align:center}
    .container{background:#fff;padding:20px;border-radius:8px;box-shadow:0 2px 10px rgba(0,0,0,.1)}
    .form-group{margin-bottom:15px}
    label{display:block;margin-bottom:5px;font-weight:bold}
    input[type=text]{width:100%;padding:8px;border:1px solid #ddd;border-radius:4px;box-sizing:border-box}
    button{background:#4CAF50;color:#fff;border:none;padding:10px 15px;border-radius:4px;cursor:pointer;font-size:16px;margin-right:10px}
    button:disabled{background:#ccc}
    #console{background:#1e1e1e;color:#d4d4d4;padding:15px;border-radius:4px;font-family:'Courier New',Courier,monospace;height:300px;overflow-y:auto;white-space:pre-wrap;margin-top:20px}
    .progress-container{margin-top:15px;display:none}
    progress{width:100%}
    .status{text-align:center;margin:10px 0;font-weight:bold}
  </style>
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
</head>
<body>
  <div class="container">
    <h1>Novel Crawler</h1>

    <div class="form-group">
      <label for="novelUrl">Novel URL:</label>
      <input type="text" id="novelUrl" placeholder="link">
    </div>

    <button id="fetchMetadataBtn">Fetch Metadata</button>
    <button id="fetchChaptersBtn" disabled>Fetch Chapters</button>
    <button id="downloadBtn" disabled>Download as JSON</button>
    <button id="saveToJsonBtn" disabled>Save JSON</button> 
    <button id="editMetadataBtn" disabled>Edit Metadata</button>
    <button id="saveMetadataBtn">Save Metadata</button>

    <div class="progress-container" id="progressContainer">
      <div class="status" id="statusText">Processing...</div>
      <progress id="progressBar" value="0" max="100"></progress>
    </div>

    <div id="console"></div>
  </div>

<script>
  // ---- DOM refs ----
  const consoleOutput   = document.getElementById('console');
  const novelUrlInput   = document.getElementById('novelUrl');
  const fetchMetadataBtn= document.getElementById('fetchMetadataBtn');
  const fetchChaptersBtn= document.getElementById('fetchChaptersBtn');
  const downloadBtn     = document.getElementById('downloadBtn');
  const saveToJsonBtn   = document.getElementById('saveToJsonBtn');
  const progressContainer = document.getElementById('progressContainer');
  const progressBar     = document.getElementById('progressBar');
  const statusText      = document.getElementById('statusText');
  const editMetadataBtn = document.getElementById('editMetadataBtn');
  const WORKER_URL = 'https://curly-pond-9050.yuush.workers.dev';

  // ---- helpers ----
  function log(msg) {
    consoleOutput.textContent += msg + '\n';
    consoleOutput.scrollTop = consoleOutput.scrollHeight;
  }

  function updateProgress(current, total) {
    const pct = Math.round((current / total) * 100);
    progressBar.value = pct;
    statusText.textContent = `Processing ${current}/${total} (${pct}%)`;
  }

  // ---- data store ----
  let novelData = { metadata: null, chapters: [] };

  // ---- fetch raw html ----
  async function fetchRawHTML(targetUrl) {
    const res = await fetch(`${WORKER_URL}/api/raw?url=${encodeURIComponent(targetUrl)}`);
    if (!res.ok) throw new Error(`raw fetch ${res.status}`);
    return res.text();
  }

  // ---- fetch metadata ----
  async function fetchMetadata() {
    const url = novelUrlInput.value.trim();
    if (!url) return alert('Please enter a novel URL');
    try {
      log('Fetching novel page…');
      fetchMetadataBtn.disabled = true;
      const chapters = [];

      async function scrapeOne(pageUrl) {
        const html = await fetchRawHTML(pageUrl);
        const doc  = new DOMParser().parseFromString(html, 'text/html');
        const $$   = sel => [...doc.querySelectorAll(sel)];
        $$('.list-chapter li a').forEach(a =>
          chapters.push({
            title: a.getAttribute('title') || a.textContent.trim(),
            url:   new URL(a.getAttribute('href'), url).href
          })
        );
        const next = $$('.pagination li.next a')[0]?.getAttribute('href');
        return next ? new URL(next, url).href : null;
      }

      let nextPage = url;
      while (nextPage) {
        log(`Scraping chapter list page → ${nextPage}`);
        nextPage = await scrapeOne(nextPage);
      }

      const html = await fetchRawHTML(url);
      const doc  = new DOMParser().parseFromString(html, 'text/html');
      const $    = sel => doc.querySelector(sel);
      const $$   = sel => [...doc.querySelectorAll(sel)];

      const title       = $('.col-xs-12.col-sm-8.col-md-8.desc h3.title')?.textContent?.trim();
      const coverPath   = $('.col-xs-12.col-sm-4.col-md-4.info-holder .book img')?.getAttribute('src');
      const cover       = coverPath ? new URL(coverPath, url).href : '';
      const authorNodes = $$('.info div').find(d => d.querySelector('h3')?.textContent?.trim() === 'Author:')?.querySelectorAll('a');
      const authors     = authorNodes ? [...authorNodes].map(a => a.textContent.trim()) : [];
      const genres      = $$('.info div').find(d => d.querySelector('h3')?.textContent?.trim() === 'Genre:')?.querySelectorAll('a');
      const genreNames  = genres ? [...genres].map(a => a.textContent.trim()) : [];
      const status      = $$('.info div').find(d => d.querySelector('h3')?.textContent?.trim() === 'Status:')?.querySelector('a')?.textContent?.trim();
      const source      = $$('.info div').find(d => d.querySelector('h3')?.textContent?.trim() === 'Source:')?.textContent?.replace('Source:', '').trim();
      const description = $('.col-xs-12.col-sm-8.col-md-8.desc .desc-text')?.textContent?.trim();

      novelData.metadata = { title, cover, author: authors, genres: genreNames, status, source, description };
      novelData.chapters = chapters;

      log(`\n=== Metadata ===`);
      log(`Title: ${title}`);
      log(`Cover: ${cover}`);
      log(`Author: ${authors.join(', ')}`);
      log(`Status: ${status}`);
      log(`Genres: ${genreNames.join(', ')}`);
      log(`Description: ${description}`);
      log(`\nTotal chapters found: ${chapters.length}`);

      fetchChaptersBtn.disabled = false;
      checkTitle();
    } catch (err) {
      log(`Error: ${err.message}`);
      fetchMetadataBtn.disabled = false;
    }
  }

  // ---- fetch chapter content ----
  async function fetchChapterContent(chapterUrl) {
    const html = await fetchRawHTML(chapterUrl);
    const doc  = new DOMParser().parseFromString(html, 'text/html');
    const novelTitle = doc.querySelector('.col-xs-12 a.truyen-title')?.textContent?.trim() || '';
    const chTitle    = doc.querySelector('.col-xs-12 h2')?.textContent?.trim() || '';
    const title      = `${novelTitle} - ${chTitle}`;
    let content = doc.querySelector('#chapter-content')?.innerHTML || 'Chapter not found';
    content = content
      .replace(/<iframe[^>]*>.*?<\/iframe>/gis, '')
      .replace(/<!--.*?-->/gs, '')
      .replace(/<p>\s*<\/p>/g, '')
      .replace(/<img[^>]*>/g, '')
      .replace(/<js[^>]*>/g, '')
      .replace(/<div\b[^>]*>\s*<\/div>/gis, '')
      .replace(/<script\b[^>]*>.*?<\/script>/gis, '')
      .replace(/<noscript\b[^>]*>.*?<\/noscript>/gis, '')
      .replace(/<div[^>]*class\s*=\s*["']ads[^>]*>.*?<\/div>/gis, '')
      .replace(/<p>Source: .*?novlove\.com<\/p>/gi, '')
      .replace(/<input[^>]*name\s*=\s*["']IL_IN_ARTICLE["'][^>]*>/gis, '')
      .trim();
    return { title, content };
  }

  // ---- fetch all chapters ----
  async function fetchChapters() {
    if (!novelData.chapters.length) return alert('No chapters found');
    try {
      fetchChaptersBtn.disabled = true;
      progressContainer.style.display = 'block';
      const batchSize = 100;
      const total = novelData.chapters.length;
      let done = 0;
      for (let i = 0; i < total; i += batchSize) {
        const slice = novelData.chapters.slice(i, i + batchSize);
        const results = await Promise.all(slice.map(async (ch, idx) => {
          log(`Fetching ${i + idx + 1}/${total} - ${ch.title}`);
          const data = await fetchChapterContent(ch.url);
          return { ...ch, ...data };
        }));
        results.forEach((r, idx) => (novelData.chapters[i + idx] = r));
        done += results.length;
        updateProgress(done, total);
        await new Promise(r => setTimeout(r, 300));
      }
      log('\nAll chapters fetched!');
      downloadBtn.disabled = false;
      saveToJsonBtn.disabled = false;
      progressContainer.style.display = 'none';
      saveJsonToGoogleDrive();
    } catch (err) {
      log(`Error: ${err.message}`);
      fetchChaptersBtn.disabled = false;
      progressContainer.style.display = 'none';
    }
  }

  // ---- save metadata function ----
  async function saveMetadata(metadata) {
    if (!metadata) return alert('No metadata available to save');
    try {
      console.log('Sending metadata:', metadata);
      const response = await fetch(`${WORKER_URL}/api/saveMetadata`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(metadata)
      });
      const result = await response.json();
      if (result.success) {
        alert(result.message || 'Metadata saved successfully');
        console.log('Save result:', result);
      } else {
        alert('Error saving metadata: ' + (result.error || 'Unknown error'));
        console.error('Save error:', result);
      }
    } catch (error) {
      alert('Error saving metadata: ' + error.message);
      console.error('Save failed:', error);
    }
  }

  // ---- create epub function ----
  async function createEpub(novelData, logFn = console.log) {
    if (!novelData.metadata?.title || !novelData.chapters[0]?.content) {
      alert('No chapter data available to create an EPUB.');
      return null;
    }
    try {
      logFn('Generating EPUB...');
      const generator = new EpubGenerator(novelData);
      const epubBlob = await generator.generate(logFn);
      logFn('✓ EPUB created successfully');
      return epubBlob;
    } catch (err) {
      logFn(`EPUB generation error: ${err.message}`);
      return null;
    }
  }

  // ---- save epub to gdrive function ----
  async function saveEpubToGoogleDrive(epubBlob, fileName, folderId, logFn = console.log) {
    if (!epubBlob) return alert('No EPUB generated yet.');
    try {
      logFn('Uploading EPUB to Google Drive...');
      const formData = new FormData();
      formData.append('file', epubBlob, fileName);
      formData.append('folder', folderId);
      const response = await fetch(`${WORKER_URL}/api/saveEpubToGoogleDrive`, { method: 'POST', body: formData });
      const result = await response.json();
      if (!response.ok || !result.success) throw new Error(result.error || 'Upload failed');
      logFn(`✓ Successfully saved EPUB to Google Drive`);
      logFn(`File: ${result.webViewLink}`);
      logFn(`File ID: ${result.fileId}`);
    } catch (error) {
      logFn(`Error: ${error.message}`);
    }
  }

  // ---- events ----
  fetchMetadataBtn.addEventListener('click', fetchMetadata);
  fetchChaptersBtn.addEventListener('click', fetchChapters);
  document.getElementById('saveMetadataBtn').addEventListener('click', () => saveMetadata(novelData.metadata));

  // download JSON
  function downloadJson() {
    if (!novelData.metadata?.title) return alert('No data to save');
    const cleanData = { ...novelData, chapters: novelData.chapters.map(({ url, ...rest }) => rest) };
    const blob = new Blob([JSON.stringify(cleanData, null, 2)], { type: 'application/json' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = `${novelData.metadata.title.replace(/[^a-z0-9]/gi, '_')}.json`;
    a.click();
    URL.revokeObjectURL(a.href);
  }
  downloadBtn.addEventListener('click', downloadJson);

  async function saveJsonToGoogleDrive() {
    if (!novelData.metadata?.title) return alert('No data to save');
    try {
      saveToJsonBtn.disabled = true;
      log('Preparing data for Google Drive...');
      const cleanData = { ...novelData, chapters: novelData.chapters.map(({ url, ...rest }) => rest) };
      const jsonContent = JSON.stringify(cleanData, null, 2);
      log('Starting upload...');
      const response = await fetch(`${WORKER_URL}/api/saveToGoogleDrive`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ title: `${novelData.metadata.title}`, content: jsonContent, folder: '16D-B7--4_NOjICRqDnHg0Z0SRH-SiWrH' })
      });
      const result = await response.json();
      if (!response.ok || !result.success) throw new Error(result.error || 'Upload failed with unknown error');
      log(`✓ Successfully saved to Google Drive`);
      log(`File: ${result.webViewLink}`);
      log(`File ID: ${result.fileId}`);
    } catch (error) {
      log(`Error: ${error.message}`);
    } finally {
      saveToJsonBtn.disabled = false;
    }
  }
  saveToJsonBtn.addEventListener('click', saveJsonToGoogleDrive);

  // --- EPUB buttons ---
  let generatedEpubBlob = null;
  const createEpubBtn = document.createElement('button');
  createEpubBtn.textContent = 'Create EPUB';
  createEpubBtn.disabled = true;
  const downloadEpubBtn = document.createElement('button');
  downloadEpubBtn.textContent = 'Download EPUB';
  downloadEpubBtn.disabled = true;
  const saveEpubBtn = document.createElement('button');
  saveEpubBtn.textContent = 'Save EPUB';
  saveEpubBtn.disabled = true;
  document.querySelector('.container').appendChild(createEpubBtn);
  document.querySelector('.container').appendChild(downloadEpubBtn);
  document.querySelector('.container').appendChild(saveEpubBtn);

  createEpubBtn.addEventListener('click', async () => {
    generatedEpubBlob = await createEpub(novelData, log);
    if (generatedEpubBlob) {
      downloadEpubBtn.disabled = false;
      saveEpubBtn.disabled = false;
    }
  });

  downloadEpubBtn.addEventListener('click', () => {
    if (!generatedEpubBlob) return alert('No EPUB generated yet.');
    const a = document.createElement('a');
    a.href = URL.createObjectURL(generatedEpubBlob);
    a.download = `${novelData.metadata.title.replace(/[^a-z0-9]/gi, '_')}.epub`;
    a.click();
    URL.revokeObjectURL(a.href);
    log('EPUB download started.');
  });

  saveEpubBtn.addEventListener('click', () => {
    saveEpubToGoogleDrive(generatedEpubBlob, `${novelData.metadata.title}.epub`, '1_P5VjIMg8PTp6_4en8d23hngim4NXED6', log);
  });

  fetchChaptersBtn.addEventListener('click', () => {
    const check = setInterval(() => {
      if (novelData.chapters.length && novelData.chapters[0]?.content) {
        createEpubBtn.disabled = false;
        clearInterval(check);
      }
    }, 500);
  });

  // --- title check ---
  async function checkTitle() {
    if (!novelData.metadata?.title) return;
    try {
      log(`Checking title against database...`);
      const res = await fetch(`${WORKER_URL}/titles.json`);
      if (!res.ok) throw new Error(`Failed to fetch titles.json (${res.status})`);
      const data = await res.json();
      const targetTitle = novelData.metadata.title.trim().toLowerCase();
      const match = data.some(item => item.title.trim().toLowerCase() === targetTitle);
      const message = match ? 'Duplicate' : 'Original';
      const style = match ? 'color: red; font-weight: bold;' : 'color: green; font-weight: bold;';
      consoleOutput.innerHTML += `<div style="${style}">Title check result: ${message}</div>`;
    } catch (err) {
      log(`Error checking title: ${err.message}`);
    }
  }
</script>
</body>
</html>
